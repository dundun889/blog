# React组件进阶

+ [ ] children属性
+ [ ] props校验
+ [ ] props默认值
+ [ ] 生命周期与钩子函数

## children属性

**目标：**掌握props中children属性的用法

**内容**：

+ children属性：表示该组件的子节点，只要组件有子节点，props就有该属性

+ children 属性与普通的props一样，值可以是任意值（文本、React元素、组件，甚至是函数）

**核心代码**

```jsx
function Hello(props) {
  return (
    <div>
      该组件的子节点：{props.children}
    </div>
  )
}

<Hello>我是子节点</Hello>
```

## props校验  

**目标：**校验接收的props的数据类型，增加组件的健壮性

**内容：**

对于组件来说，props是外来的，无法保证组件使用者传入什么格式的数据 

如果传入的数据格式不对，可能会导致组件内部报错。**组件的使用者不能很明确的知道错误的原因。** 

![](images/props校验-16360169758301.png)

props校验允许在创建组件的时候，就约定props的格式、类型等

![](images/props校验02-16360169758302.png)

作用：规定接收的props的类型必须为数组，如果不是数组就会报错，增加组件的健壮性。

![](images/props校验03-16360169758303.png)

**核心代码：**

+ 导入 `prop-types` 包 
+ 使用`组件名.propTypes = {}` 来给组件的props添加校验规则
+ 校验规则通过 `PropTypes` 对象来指定

```jsx
import PropTypes from 'prop-types'
function App(props) {
    return (
    	<h1>Hi, {props.colors}</h1>
    )
}
App.propTypes = {
    // 约定colors属性为array类型
    // 如果类型不对，则报出明确错误，便于分析错误原因
    colors: PropTypes.array
}
```

**总结：**

通过props校验，能够增强组件的健壮性

## props校验-规则

**目标：**了解react组件props校验的常见规则 

**内容：**

1. 常见类型：array、bool、func、number、object、string
2. React元素类型：element
3. 必填项：isRequired
4. 特定结构的对象：shape({})

**核心代码**

```jsx
// 常见类型
optionalFunc: PropTypes.func,
// 必选
requiredFunc: PropTypes.func.isRequired,
// 特定结构的对象
optionalObjectWithShape: PropTypes.shape({
	color: PropTypes.string,
	fontSize: PropTypes.number
})
```

## props默认值(了解)

**目标：**给组件的props提供默认值

**内容：**

通过`defaultProps`可以给组件的props设置默认值，在未传入props的时候生效

**核心代码：**

```jsx
function App(props) {
    return (
        <div>
            此处展示props的默认值：{props.pageSize}
        </div>
    )
}
// 设置默认值
App.defaultProps = {
	pageSize: 10
}
// 不传入pageSize属性
<App />
```

## 类的静态属性-static

**目标：**能够通过类的static语法简化props校验和默认值

**内容：**

+ 实例成员: 通过实例调用的属性或者方法，，，叫做实例成员（属性或者方法）
+ 静态成员：通过类或者构造函数本身才能访问的属性或者方法

**核心代码**

```jsx
class Person {
   name = 'zs',
   static age = 18
   sayHi() {
       console.log('哈哈')
   }
   static goodBye() {
       console.log('byebye')
   }
}

const p = new Person()

console.log(p.name)
p.sayHi()

console.log(Person.age)
Person.goodBye()
```

## 组件生命周期-概述

**目的：**能够理解什么是组件的生命周期以及为什么需要研究组件的生命周期

**内容：**

+ 生命周期：一个事物从创建到最后消亡经历的整个过程
+ 组件的生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程

+ 意义：组件的生命周期有助于理解组件的运行方式、完成更复杂的组件功能、分析组件错误原因等
+ 钩子函数的作用：为开发人员在不同阶段操作组件提供了时机。
+ **只有 类组件 才有生命周期。**

![人一生缩影](images/人一生缩影.png)

## 组件生命周期-整体说明

**目标：**能够说出组件生命周期总共有几个阶段。

**内容：**

+ <http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/>

![image-20211105104421145](images/image-20211105104421145.png)

## 组件生命周期-挂载阶段

**目标：**能够说出组件的挂载阶段的钩子函数以及执行时机

**内容：**

+ 执行时机：组件创建时（页面加载时）

+ 执行顺序：

![](images/组件的执行顺序.png)

| 钩子 函数         | 触发时机                  | 作用                                     |
| ----------------- | ------------------------- | ---------------------------------------- |
| constructor       | 创建组件时，最先执行      | 1. 初始化state  2. 创建Ref等             |
| render            | 每次组件渲染都会触发      | 渲染UI（**注意： 不能调用setState()** ） |
| componentDidMount | 组件挂载（完成DOM渲染）后 | 1. 发送网络请求   2.DOM操作              |

## 组件生命周期-更新阶段

**目标：**能够说出组件的更新阶段的钩子函数以及执行时机

**内容：**

+ 执行时机：1. setState() 2. forceUpdate() 3. 组件接收到新的props
+ 说明：以上三者任意一种变化，组件就会重新渲染
+ 执行顺序

![](images/更新阶段.png)

| 钩子函数           | 触发时机                  | 作用                                                 |
| ------------------ | ------------------------- | ---------------------------------------------------- |
| render             | 每次组件渲染都会触发      | 渲染UI（与 挂载阶段 是同一个render）                 |
| componentDidUpdate | 组件更新（完成DOM渲染）后 | DOM操作，可以获取到更新后的DOM内容，不要调用setState |

## 组件生命周期-卸载阶段

**目标：**能够说出组件的销毁阶段的钩子函数以及执行时机

**内容**   

+ 执行时机：组件从页面中消失  

| 钩子函数             | 触发时机                 | 作用                               |
| -------------------- | ------------------------ | ---------------------------------- |
| componentWillUnmount | 组件卸载（从页面中消失） | 执行清理工作（比如：清理定时器等） |

## setState进阶-更新数据的说明

**目的**：能够理解setState是"异步"的

**内容：**

+ setState方法是异步的【*这句话有毛病，暂且这么理解*】

+ 当调用 setState 的时候，React.js 并不会马上修改 state （为什么）
+ 而是把这个对象放到一个更新队列里面
+ 稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。

+ 可以多次调用 setState() ，只会触发一次重新渲染

```js
this.state = { count: 1 }
this.setState({
	count: this.state.count + 1
})
console.log(this.state.count) // 1
```

在使用 React.js 的时候，并不需要担心多次进行 `setState` 会带来性能问题。

## setState进阶-推荐语法

**目标：**能够掌握setState箭头函数的语法，解决多次调用依赖的问题

**内容：**

+  推荐：使用 `setState((preState) => {})` 语法

+  参数preState: React.js 会把上一个 `setState` 的结果传入这个函数

```js
this.setState((preState) => {
    return {
    	count: preState.count + 1
    }
})
console.log(this.state.count) // 1
```

**这种语法依旧是异步的，但是state可以获取到最新的状态，适用于需要调用多次setState**

## setState进阶-第二个参数

**目标：**能够使用setState的回调函数，操作渲染后的DOM

**内容：**

+ 场景：在状态更新（页面完成重新渲染）后立即执行某个操作
+ 语法：`setState(updater[, callback])`

```js
this.setState(
	(state) => ({}),
	() => {console.log('这个回调函数会在状态更新后立即执行')}
)
```

## setState进阶-同步or异步

**目标：**能够说出setState到底是同步的还是异步

**内容：**

+ setState本身并不是一个异步方法，其之所以会表现出一种异步的形式，是因为react框架本身的一个性能优化机制
+ React会将多个setState的调用合并为一个来执行，也就是说，当执行setState的时候，state中的数据并不会马上更新
+ setState如果是在react的生命周期中或者是事件处理函数中，表现出来是*异步的*
+ setState如果是在setTimeout/setInterval或者原生事件中，表现出来是*同步的*

**总结：**

+ setState是同步的方法，但是react为了性能优化，所以setState在react的事件中表现得像异步。
+ 参考链接：https://zhuanlan.zhihu.com/p/158725289

## 综合案例-B站评论列表案例

+ 核心代码

```jsx
componentDidUpdate() {
  localStorage.setItem('list', JSON.stringify(this.state.list))
}
componentDidMount() {
  const list = JSON.parse(localStorage.getItem('list')) || []
  this.setState({ list })
}
```

## 综合案例-todomc

### json-server模拟接口

+ 准备文件data.json

```jsx
{
  "todos": [
    {
      "id": 1,
      "name": "死豆",
      "done": false
    },
    {
      "name": "打死豆豆",
      "done": true,
      "id": 4
    }
  ]
}

```

+ 使用json-server启动接口

```jsx
npx json-server data.json --port 8888
```

+ 接口地址

```jsx
http://localhost:8888/todos

增加： post
删除： delete
修改： patch  / put
获取： get
```

### 列表渲染功能

**核心步骤**

1. App组件中通过axios发送请求获取到列表
2. 通过父传子把list传递给TodoMain组件
3. TodoMain组件渲染任务列表